#include <assert.h>   // assert()
#include <stdio.h>    // printf() and snprintf()
#include <stdlib.h>   // malloc() and free()
#include <string.h>   // memset()
#include "expr.h"

#define EmitIR  printf
/////////////////////////////////////////////////////////////////////

// the number of temporary variables
static int tmpNo;

/////////////////////////////////////////////////////////////////////

// Temporary variables are named as "t0", "t1", "t2", .... 
// They are generated by arithmetic operations like a+b, a-b, a*b, a/b.
static int NewTemp(void) {  
    return tmpNo++;
}

/*
  Create an Ast node for an expression.
 */
static AstExprNodePtr CreateAstExprNode(TokenKind tk, long numVal, char *operator, AstExprNodePtr left,
                         AstExprNodePtr right) {
    AstExprNodePtr pNode = (AstExprNodePtr) malloc(sizeof(struct astExprNode));
    assert(pNode != NULL);

    memset(pNode, 0, sizeof(*pNode));
    // The kind of an expression node
    pNode->op = tk;
    if (tk == TK_NUM) { // an operand like 9000
        // 9000
        pNode->value.numVal = numVal;
        // "9000"
        snprintf(pNode->value.name, MAX_ID_LEN, "%ld", numVal);    
    } else { // an operator: + - * /
        // A temporary variable's name: "t0", "t1" 
        snprintf(pNode->value.name, MAX_ID_LEN, "t%d", NewTemp());  
    }  
    pNode->leftChild = left;
    pNode->rightChild = right;
    return pNode;
}


void ReleaseAstExpr(AstExprNodePtr root) {
    if (root) {
        ReleaseAstExpr(root->leftChild);
        ReleaseAstExpr(root->rightChild);
        free(root);
    }
}


AstExprNodePtr Expression(void) {
    ///////////////////////////////////////////////////////////////////
    //
    //  An expression (i.e., a string) from a user:
    //       
    //      "9000 + 6 * 4" 
    //
    //  Its binary-tree representation:
    //
    //        +
    //      /   \
    //    9000   *
    //          /  \
    //         6    4
    // 
    //
    // Q1. How to create a binary tree?
    // Q2. How to visit a binary tree?
    //
    ///////////////////////////////////////////////////////////////////

    // Now, let's manually create the binary tree. 
    // We will write a parser to create the tree for us later.
    AstExprNodePtr left = CreateAstExprNode(TK_NUM, 9000, "", NULL, NULL);
    AstExprNodePtr rightLeft = CreateAstExprNode(TK_NUM, 6, "", NULL, NULL);
    AstExprNodePtr rightRight = CreateAstExprNode(TK_NUM, 4, "", NULL, NULL);
    AstExprNodePtr right = CreateAstExprNode(TK_MUL, 0, "*", rightLeft, rightRight);
    AstExprNodePtr root = CreateAstExprNode(TK_ADD, 0, "+", left, right);

    return root;
}


// In fact, it is a simple interpreter
long EvalExpression(AstExprNodePtr root) {    
    assert(root);
    if (root->op == TK_NUM) {  // 9000, 6, 4      
        return root->value.numVal;
    }
    else { // +, -, *, /
        assert(root->leftChild);
        assert(root->rightChild);        
        long leftOperand = EvalExpression(root->leftChild);
        long rightOperand = EvalExpression(root->rightChild); 
        // Postorder traversal:
        //     a tree traversal method that adheres to the Left-Right-Root policy
        long result = 0;
        switch (root->op) {
        case TK_ADD:              
            result = leftOperand + rightOperand;
            EmitIR("%s = %s + %s\n", root->value.name, 
                                     root->leftChild->value.name, 
                                     root->rightChild->value.name);
            break;
        case TK_SUB:
            result = leftOperand - rightOperand;
            EmitIR("%s = %s - %s\n", root->value.name, 
                                     root->leftChild->value.name, 
                                     root->rightChild->value.name);              
            break;
        case TK_MUL:
            result = leftOperand * rightOperand;
            EmitIR("%s = %s * %s\n", root->value.name, 
                                     root->leftChild->value.name, 
                                     root->rightChild->value.name);             
            break;
        case TK_DIV:
            result = leftOperand / rightOperand;
            EmitIR("%s = %s / %s\n", root->value.name, 
                                     root->leftChild->value.name, 
                                     root->rightChild->value.name);               
            break;
        default:
            break;              
        }
        return result;
    } 
}
