#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "expr.h"
#include "error.h"
#include "lex.h"
#include "Queue.h"


#define TEMP_VAR_NAME_FMT  "t%d"

#define EmitIR  printf


/////////////////////////////////////////////////////////////////////

// the number of temporary variables
static int tmpNo;


/////////////////////////////////////////////////////////////////////

// Temporary variables are named as "t0", "t1", "t2", .... 
// They are generated by arithmetic operations like a+b, a-b, a*b, a/b.
static int NewTemp(void) {  
  return tmpNo++;
}

/*
  Create an Ast node for an expression.
 */
AstExprNodePtr CreateAstExprNode(TokenKind tk, Value *pVal, AstExprNodePtr left,
                         AstExprNodePtr right) {
  AstExprNodePtr pNode = (AstExprNodePtr) malloc(sizeof(struct astExprNode));
  assert(pNode != NULL && pVal != NULL);

  memset(pNode, 0, sizeof(*pNode));
  pNode->op = tk;
  pNode->value = *pVal;
  pNode->kids[0] = left;
  pNode->kids[1] = right;

  pNode->onstack = 0;
  pNode->evaluated = 0;
  return pNode;
}

/*
  PrimaryExpression:
      NUM
      (Expression)
 */
static AstExprNodePtr PrimaryExpression(void) {
  AstExprNodePtr expr = NULL;
  if (curToken.kind == TK_NUM) {
    expr = CreateAstExprNode(curToken.kind, &curToken.value, NULL, NULL);
    NEXT_TOKEN;
  } 
  else if (curToken.kind == TK_LPAREN) {
    NEXT_TOKEN;
    expr = Expression();
    Expect(TK_RPAREN);
  } 
  else {
    Error("number or '(' expected");
  }
  return expr;
}

/*
  Here, stands for a multiplicative operator.

  mop:
              *  
              /
  
  MultiplicativeExpression:
          PrimaryExpression
          PrimaryExpression  mop PrimaryExpression  ...   mop PrimaryExpression
 */
static AstExprNodePtr MultiplicativeExpression(void) {
  AstExprNodePtr left;
  left = PrimaryExpression();
  while (curToken.kind == TK_MUL || curToken.kind == TK_DIV) {
    Value value;
    AstExprNodePtr expr;
    memset(&value, 0, sizeof(value));    
    snprintf(value.name, MAX_ID_LEN, TEMP_VAR_NAME_FMT, NewTemp());
    // create a tree node for * or /
    expr = CreateAstExprNode(curToken.kind, &value, NULL, NULL);
    // skip '*' or '/'
    NEXT_TOKEN;
    expr->kids[0] = left;
    expr->kids[1] = PrimaryExpression();
    left = expr;
  }
  return left;
}

/*
  Here, aop stands for an additive operator.

  aop:
              +  
              -

  AdditiveExpression:
        MultiplicativeExpression
        MultiplicativeExpression  aop MultiplicativeExpression  ...   aop MultiplicativeExpression 
 */
static AstExprNodePtr AdditiveExpression(void) {
  AstExprNodePtr left;
  /*  
      Take "9000  +  ( 6  *  4 )" as an example.

      9000  +  ( 6  *  4 )
      ^
      ^
      Current Token

      Let's call MultiplicativeExpression() to parse the first MultiplicativeExpression in an AdditiveExpression.
      MultiplicativeExpression() will return a sub-tree for "9000"      
   */
  left = MultiplicativeExpression();
  /*
    Now, the curToken points to '+' (i.e, TK_ADD)

    9000  +  ( 6  *  4 )
          ^
          ^
          Current Token

    Parse "aop MultiplicativeExpression" if they are in the input stream
   */
  while (curToken.kind == TK_SUB || curToken.kind == TK_ADD) {
    Value value;
    AstExprNodePtr expr;
    memset(&value, 0, sizeof(value));
    // A temporary variable "t0" is assigned the value resulting from the expression "t0 = 9000 + t1".
    // "t1 = 6 * 4" will be created in MultiplicativeExpression() later.    
    snprintf(value.name, MAX_ID_LEN, TEMP_VAR_NAME_FMT, NewTemp());
    // create a tree node for '+' or '-'
    expr = CreateAstExprNode(curToken.kind, &value, NULL, NULL);
    // skip '+' or '-'
    NEXT_TOKEN;
    /*
      Now, the curToken points to '('

      9000  +  ( 6  *  4 )
               ^
               ^
               Current Token
            
      Call MultiplicativeExpression() to parse the right operand "(6 * 4)"
      Again, it will return a sub-tree for "(6 * 4)"
    */    
    expr->kids[0] = left;
    expr->kids[1] = MultiplicativeExpression();
    /*
      If the current token is '+' or '-', The while-loop will iterate once more.
      Otherwise, the while-loop will stop, meaning our parser has recognized an additive expression
      in the input stream.

      In this simple example, now, the current token is TK_EOF (end of file).

      9000  +  ( 6  *  4 ) 
                            ^
                            ^
                            Current Token
      
     */
    left = expr;
  }
  return left;
}

void ReleaseAstExpr(AstExprNodePtr root) {
  if (root) {
    ReleaseAstExpr(root->kids[0]);
    ReleaseAstExpr(root->kids[1]);
    free(root);
  }
}

/*
  Expression:
      AdditiveExpression
  */
AstExprNodePtr Expression(void) { 
  return AdditiveExpression(); 
}

static int isArithmeticOperator(TokenKind tk) {
  return tk == TK_ADD || tk == TK_SUB || tk == TK_MUL || tk == TK_DIV;
}

#define FIRST_ARRIVAL		 1
#define LEFT_OPERAND_EVALUATED   2
#define RIGHT_OPERAND_EVALUATED  3
#define OPERATOR_EVALUATED  4

static long imgCount = 1;

// In fact, it is a simple interpreter
long EvalExpression(AstExprNodePtr root, AstExprNodePtr whileTree) {    
    assert(root);
    root->onstack = 1;

    char *graphName = "BiTree";
    char *fileName = "images/BiTree";


    if (root->op == TK_NUM) {  // 9000, 6, 4
    	BiTreeGenOneImage(whileTree, graphName, fileName, imgCount);
    	imgCount++;    
        root->onstack = 0;        
        return root->value.numVal;
    }
    else if (isArithmeticOperator(root->op)) { // +, -, *, /
        //
        assert(root->kids[0]);
        assert(root->kids[1]); 	
       
        
        root->evaluated = FIRST_ARRIVAL;
        
    	BiTreeGenOneImage(whileTree, graphName, fileName, imgCount);
    	imgCount++;
    	            
        long leftOperand = EvalExpression(root->kids[0], whileTree);
        root->evaluated = LEFT_OPERAND_EVALUATED;

        BiTreeGenOneImage(whileTree, graphName, fileName, imgCount);
        imgCount++;

        long rightOperand = EvalExpression(root->kids[1], whileTree);
        root->evaluated = RIGHT_OPERAND_EVALUATED;

        BiTreeGenOneImage(whileTree, graphName, fileName, imgCount);
        imgCount++;        

        // Postorder traversal
        long result = 0;
        switch (root->op) {
            case TK_ADD:                
                result = leftOperand + rightOperand;
                root->value.numVal = result;                
                EmitIR("%s = %s + %s\n", root->value.name, 
                                         root->kids[0]->value.name, 
                                         root->kids[1]->value.name);
                break;
            case TK_SUB:
                result = leftOperand - rightOperand;
                root->value.numVal = result;
                EmitIR("%s = %s - %s\n", root->value.name, 
                                         root->kids[0]->value.name, 
                                         root->kids[1]->value.name);              
                break;
            case TK_MUL:
                result = leftOperand * rightOperand;
                root->value.numVal = result;
                EmitIR("%s = %s * %s\n", root->value.name, 
                                         root->kids[0]->value.name, 
                                         root->kids[1]->value.name);             
                break;
            case TK_DIV:
                result = leftOperand / rightOperand;
                root->value.numVal = result;
                EmitIR("%s = %s / %s\n", root->value.name, 
                                         root->kids[0]->value.name, 
                                         root->kids[1]->value.name);               
                break;
            default:
                break;              
        }
        root->evaluated = OPERATOR_EVALUATED;

        BiTreeGenOneImage(whileTree, graphName, fileName, imgCount);
        imgCount++;
        root->onstack = 0;
        return result;
    } else {
      Error("Unknown operator/operand");
      root->onstack = 0;
      return 0;
    }
}


//////////////////////////// Tree2Dot (for visualizing the algorithm) /////////////////////

void BiTree2Dot(AstExprNodePtr root, 
               char *filePath,
               char *graphName,
               int displayVisited) {
    (void) displayVisited;
    FILE *dotFile = fopen(filePath, "w");
    /*
        FIXME:  check sanity of the parameters.
     */
    if (dotFile) {
        char *edgeConnectorStr = "->";
        fprintf(dotFile, "digraph %s {\n", graphName);
        
        struct Queue *pQueue = CreateQueue();
        if (root) {
            QueueEnqueue(pQueue, root);
            while (!QueueIsEmpty(pQueue)) {
                AstExprNodePtr curNode = QueueDequeue(pQueue);

                char *onStackStr = " ";
                if (curNode->onstack) {
                  onStackStr = "[shape=box] [color=red]";
                }
                if (curNode->op == TK_NUM) {
                  fprintf(dotFile, "\"%p\" [label=\"%s\"] %s\n", 
                          curNode, curNode->value.name, onStackStr);
                } else {
                  const char *opName = GetTokenName(curNode->op);
                  if (curNode->evaluated == FIRST_ARRIVAL) {
                    fprintf(dotFile, "\"%p\" [label=\"? %s ? = ?\"] %s\n", 
                            curNode, 
                            opName, 
                            onStackStr);
                  } else if (curNode->evaluated == LEFT_OPERAND_EVALUATED) {
                    fprintf(dotFile, "\"%p\" [label=\"%ld %s ? = ?\"] %s\n", 
                            curNode, 
                            curNode->kids[0]->value.numVal, 
                            opName, 
                            onStackStr);
                  } else if (curNode->evaluated == RIGHT_OPERAND_EVALUATED) {
                    fprintf(dotFile, "\"%p\" [label=\"%ld %s %ld = ?\"] %s\n", 
                            curNode, 
                            curNode->kids[0]->value.numVal, 
                            opName,
                            curNode->kids[1]->value.numVal,
                            onStackStr);                 
                  } else if (curNode->evaluated == OPERATOR_EVALUATED) {
                    fprintf(dotFile, "\"%p\" [label=\"%ld %s %ld = %ld\"] %s\n", 
                            curNode, 
                            curNode->kids[0]->value.numVal, 
                            opName,
                            curNode->kids[1]->value.numVal,
                            curNode->value.numVal, 
                            onStackStr);                      
                  } else {
                    fprintf(dotFile, "\"%p\" [label=\"%s\"] %s\n", 
                            curNode, opName, onStackStr);
                  }
                }
                
                if (curNode->kids[0]) {
                    fprintf(dotFile, "\"%p\" %s {\"%p\"} [label=\"L\"]\n",
                            curNode,
                            edgeConnectorStr,                         
                            curNode->kids[0]);
                    QueueEnqueue(pQueue, curNode->kids[0]);
                }
                if (curNode->kids[1]) {
                    fprintf(dotFile, "\"%p\" %s {\"%p\"} [label=\"R\"]\n",                        
                            curNode, 
                            edgeConnectorStr,
                            curNode->kids[1]);
                    QueueEnqueue(pQueue, curNode->kids[1]);
                }                
            }
        }
        ReleaseQueue(pQueue);
        // /*
        // "0" [color=red]
        //  */
        // if (displayVisited) {
        //     DisplayVisited(dotFile, root);
        // }        
        fprintf(dotFile, "}\n");
        fclose(dotFile);
    }                
}

#define FILE_NAME_LEN  255

void BiTreeGenOneImage(AstExprNodePtr root, char *graphName, char *fileName, long seqNo) {
    char dotFileName[FILE_NAME_LEN+1] = {0};
    char pngFileName[FILE_NAME_LEN+1] = {0};
    char command[(FILE_NAME_LEN+1)*4] = {0};
    
    snprintf(dotFileName, FILE_NAME_LEN, "%s_%04ld.dot", fileName, seqNo);
    snprintf(pngFileName, FILE_NAME_LEN, "%s_%04ld.png", fileName, seqNo);

    BiTree2Dot(root, dotFileName, graphName, 1);

    snprintf(command, FILE_NAME_LEN*4, "dot -T png %s -o %s", dotFileName, pngFileName);

    //printf("%s\n", command);
    
    // Execute the command in a child process (fork() + exec() on Linux)
    system(command); 

}


